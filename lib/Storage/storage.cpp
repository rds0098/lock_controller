#include <storage.h>
#include <ardu_cam.h>


extern uint8_t buffer[IMG_BUFFER_SIZE] ;

typedef enum
{
    IMG_SECTOR_1 = 1,
    IMG_SECTOR_2,
    IMG_SECTOR_3
}img_sector_t;

uint8_t read_img_sector[SECTOR_SIZE] = {0};
// 'dummy_image', 96x96px 
//72rows,16col; 1152bytes
//uint8_t dummy_image[IMG_BUFFER_SIZE] = {
uint8_t dummy_image[1152] = {
0x7f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xfe, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x7f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1f, 0xff, 0xe0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x42, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x61, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x88, 0x00, 0x7f, 
0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x04, 0x10, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x08, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xc1, 0x84, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x60, 0x82, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x41, 0x00, 0x00, 
0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x10, 0x30, 0x80, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x18, 0x10, 0x00, 0x00, 0x00, 0xf2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x08, 0x00, 0x00, 
0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0c, 0x20, 0x00, 0x00, 0x3d, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x10, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x03, 0x02, 0x08, 0x40, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x83, 0x08, 0x00, 
0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x81, 0x04, 0x00, 0x00, 0x07, 0xe0, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x80, 0xc1, 0x80, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xc0, 0x60, 0x82, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x60, 0x40, 0x00, 
0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x40, 0x00, 0x00, 0x00, 0xfe, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x70, 0x30, 0x20, 0x00, 0x00, 0x00, 0x7e, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x38, 0x18, 0x30, 0x40, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x08, 0x18, 0x00, 
0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x08, 0x00, 0x00, 0x00, 0x3f, 0xf0, 
0x00, 0x00, 0x00, 0x00, 0x0c, 0x06, 0x0c, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
0x06, 0x06, 0x04, 0x10, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x07, 0x03, 0x06, 0x00, 
0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x03, 0x81, 0x02, 0x00, 0x00, 0x00, 0x07, 0xff, 
0xc0, 0x00, 0x00, 0x00, 0x03, 0x81, 0x81, 0x00, 0x00, 0x00, 0x07, 0xff, 0xe0, 0x00, 0x00, 0x00, 
0x01, 0xc0, 0xc1, 0x80, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x40, 0x80, 
0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x60, 0x40, 0x00, 0x00, 0x01, 0xff, 
0xff, 0x00, 0x00, 0x00, 0x80, 0x70, 0x20, 0x40, 0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 
0xc0, 0x30, 0x10, 0x20, 0x80, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xc0, 0x38, 0x18, 0x10, 
0x00, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0xe0, 0x18, 0x08, 0x10, 0x40, 0x00, 0x00, 0x7f, 
0xff, 0xff, 0x00, 0x00, 0xe0, 0x0c, 0x0c, 0x08, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 
0xf0, 0x0e, 0x06, 0x0c, 0x20, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x78, 0x06, 0x02, 0x04, 
0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0x00, 0x28, 0x07, 0x03, 0x02, 0x00, 0x00, 0x00, 0x1f, 
0xff, 0xff, 0xff, 0xf0, 0x1c, 0x03, 0x01, 0x82, 0x08, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf8, 
0x1e, 0x03, 0x81, 0x81, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xfe, 0x1e, 0x01, 0xc0, 0xc1, 
0x80, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0x40, 0x82, 0x00, 0x00, 0x03, 
0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0xe0, 0x60, 0x41, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 
0x07, 0x80, 0x70, 0x30, 0x61, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x03, 0xc0, 0x30, 0x10, 
0x20, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x01, 0xc0, 0x18, 0x18, 0x10, 0x80, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0x01, 0xe0, 0x18, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 
0x00, 0xf0, 0x1c, 0x04, 0x08, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x70, 0x0e, 0x06, 
0x08, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x78, 0x06, 0x03, 0x04, 0x00, 0x00, 0x00, 
0x3f, 0xff, 0xff, 0xff, 0x00, 0x38, 0x07, 0x01, 0x02, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 
0x80, 0x3c, 0x03, 0x81, 0x02, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x1e, 0x01, 0x80, 
0x81, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x0f, 0x01, 0xc0, 0xc1, 0x00, 0x00, 0x00, 
0x07, 0xff, 0xff, 0xff, 0xe0, 0x07, 0x00, 0xe0, 0x60, 0x80, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 
0xb0, 0x07, 0x80, 0x60, 0x60, 0x40, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x70, 0x03, 0xc0, 0x70, 
0x30, 0x40, 0x00, 0x00, 0x01, 0xff, 0xff, 0xf0, 0xf8, 0x03, 0xc0, 0x38, 0x10, 0x20, 0x00, 0x00, 
0x01, 0xff, 0xfe, 0x00, 0xfc, 0x01, 0xe0, 0x18, 0x18, 0x10, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 
0xfc, 0x00, 0xe0, 0x1c, 0x08, 0x10, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x7e, 0x00, 0xf0, 0x0c, 
0x04, 0x08, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x3f, 0x00, 0x78, 0x06, 0x06, 0x0c, 0x00, 0x00, 
0x00, 0x0e, 0x00, 0x00, 0x1f, 0x00, 0x38, 0x07, 0x02, 0x04, 0x00, 0x00, 0x00, 0x03, 0x60, 0x00, 
0x1f, 0x80, 0x3c, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x0f, 0xc0, 0x1c, 0x03, 
0x81, 0x82, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x0f, 0xe0, 0x0e, 0x00, 0x80, 0x81, 0x00, 0x00, 
0x00, 0x00, 0x40, 0x00, 0x07, 0xe0, 0x0f, 0x00, 0xc0, 0xc0, 0x84, 0x00, 0x00, 0x00, 0x0e, 0x00, 
0x03, 0xd0, 0x07, 0x00, 0xe0, 0x60, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd0, 0x03, 0x80, 
0x60, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb8, 0x03, 0xc0, 0x30, 0x30, 0x60, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x01, 0xc0, 0x38, 0x18, 0x20, 0x00, 0x00, 0x04, 0x0c, 0x00, 
0x00, 0x7c, 0x00, 0xc0, 0x18, 0x08, 0x00, 0x00, 0x00, 0x41, 0x02, 0x80, 0x00, 0x7e, 0x00, 0x70, 
0x1c, 0x0c, 0x10, 0x40, 0x00, 0x00, 0x80, 0x10, 0x00, 0x3f, 0x00, 0x70, 0x0e, 0x04, 0x08, 0x00, 
0x00, 0x08, 0x10, 0x00, 0x00, 0x1f, 0x00, 0x38, 0x06, 0x06, 0x00, 0x00, 0x00, 0x84, 0x04, 0x00, 
0x00, 0x1f, 0x80, 0x3c, 0x03, 0x03, 0x04, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x0f, 0xc0, 0x1c, 
0x03, 0x01, 0x02, 0x00, 0x00, 0x10, 0x60, 0x00, 0x00, 0x07, 0xc0, 0x0e, 0x01, 0x80, 0x82, 0x00, 
0x00, 0x08, 0x1c, 0x00, 0x80, 0x07, 0xe0, 0x0f, 0x01, 0xc0, 0xc1, 0x00, 0x01, 0x86, 0x07, 0xe0
}; 

//  const int image_address = NVM_Offset + SECTOR_SIZE;           //passwords are stored in the first sector
// const int system_config_address = NVM_Offset + SECTOR_SIZE*4; //next three sectors reserved for image


char pass_str[10][7] = {"123456","643211","345612","125634","145623","345126","129456","128856","125556","124456"}; 
char pass_clear[7]   = "FFFFFF"; 

extern char obtained_pass_code[6];

void write_passwords_to_nvs(void)
{   
    ESP.flashEraseSector((passcodes_address)/SECTOR_SIZE);
    for(int i = 0; i< MAX_NUM_PASS; i++)
    {
        ESP.flashWrite(passcodes_address+(i*PASS_NUM_LENGTH), (uint32_t *)&pass_str[i], PASS_NUM_LENGTH);
        delay(100);
    }

}
void write_configurations_to_nvs(dev_config_t *config)
{
    ESP.flashEraseSector((system_config_address)/SECTOR_SIZE);
    ESP.flashWrite(system_config_address, (uint32_t *)config, sizeof(dev_config_t));
}
void erase_configurations_from_nvs(void)
{
    ESP.flashEraseSector((system_config_address)/SECTOR_SIZE);
}
void erase_image_sector(void)
{
    ESP.flashEraseSector((image_address)/SECTOR_SIZE);
}
bool read_configurations_from_nvs(dev_config_t *config)
{
    if(ESP.flashRead(system_config_address, (uint32_t *)config, sizeof(dev_config_t)))
    {
        return true;
    }
    else 
        return false;
}

void clear_passwords_from_nvs(int index)
{
    char strout[MAX_NUM_PASS][PASS_NUM_LENGTH];
    //read passwords from nvs
    for(int i = 0; i< MAX_NUM_PASS; i++)
    {
        ESP.flashRead(passcodes_address+(i*PASS_NUM_LENGTH), (uint32_t *)&strout[i], PASS_NUM_LENGTH);
        delay(100);
    }

    ESP.flashEraseSector((passcodes_address)/SECTOR_SIZE);
    //update passwords
    strcpy(strout[index],pass_clear);
    //write back
    for(int i = 0; i< MAX_NUM_PASS; i++)
    {
        ESP.flashWrite(passcodes_address+(i*PASS_NUM_LENGTH), (uint32_t *)&strout[i], PASS_NUM_LENGTH);
        delay(100);
    }
}


bool is_password_correct(void)
{
    char password;
    uint8_t strout[MAX_NUM_PASS][PASS_NUM_LENGTH];
    for(int i = 0; i < MAX_NUM_PASS ; i++)
    {   
        ESP.flashRead(NVM_Offset+(i*PASS_NUM_LENGTH),(uint32_t*)&strout[i],PASS_NUM_LENGTH);
        Serial.print("Obtained passcode is: ");
        Serial.println((char*)obtained_pass_code);
        Serial.print("passcode from nvs is: ");
        Serial.println((char*)strout[i]);
        if(!strcmp(obtained_pass_code,(char*)strout[i]))
        {
            //clear password from nvs
            clear_passwords_from_nvs(i);
            Serial.println("Password Cleared from memory, can not use it again");
            return true;
            
        }
    }
    return false;
}

bool is_rcv_password_correct(char *str)
{
    uint8_t strout[MAX_NUM_PASS][PASS_NUM_LENGTH];
    for(int i = 0; i < MAX_NUM_PASS ; i++)
    {   
        ESP.flashRead(passcodes_address+(i*PASS_NUM_LENGTH),(uint32_t*)&strout[i],PASS_NUM_LENGTH);
       // Serial.println((char*)(strout+i));
        if(!strcmp(str,(char*)strout[i]))
        {
            //clear password from nvs
            clear_passwords_from_nvs(i);
            Serial.println("Password removed from index:");
            Serial.println(i);
            Serial.println("Password Received is correct");
            Serial.println("Password Cleared from memory, can not use it again");
            return true;
            
        }
    }
    return false;
}

//2 images are saved in a sector
//0 -> (SECTOR_SIZE/2)-1             //Space for first image
// (SECTOR_SIZE/2) -> SECTOR_SIZE - 1 //space for 2nd image

bool save_image_to_nvs(void)
{
    int idx = 0;
    for(int idx = 0; idx<(3*SECTOR_SIZE); idx+=SECTOR_SIZE)
    {
        memset(read_img_sector,0,SECTOR_SIZE);
        Serial.println("Reading IMAGE from nvs");
        if(!ESP.flashRead((image_address + idx), (uint32_t *)&read_img_sector, SECTOR_SIZE))
        {
            Serial.println("Flash read error");
        }
        for(int i = 0; i< SECTOR_SIZE; i++)
        {
            Serial.print(read_img_sector[i],HEX);
        }
      
        if(read_img_sector[0] == 0xFF && read_img_sector[1] == 0xD8)
        {
            //image is already saved in first half, look into second half
            Serial.println("Image already saved in first half");

            if(read_img_sector[0+(SECTOR_SIZE/2)] == 0xFF && read_img_sector[1+(SECTOR_SIZE/2)] == 0xD8)
            {
                Serial.println("Image already saved in Second half, Let's check next half");
            }
            else
            {
            //    strncpy((char*)read_img_sector+(SECTOR_SIZE/2),(char*)buffer,IMG_BUFFER_SIZE);
                for(int i = 0; i<IMG_BUFFER_SIZE; i++ )
                {
                    read_img_sector[i+(SECTOR_SIZE/2)] = buffer[i];
                    
                }

                ESP.flashEraseSector((image_address + idx)/SECTOR_SIZE);
                Serial.println("Writing image to nvs");

                ESP.flashWrite((image_address + idx), (uint32_t *)&read_img_sector, SECTOR_SIZE);

                Serial.print("Image saved to image sector: ");
                Serial.print(idx);
                Serial.println(" - Second half");
                return true;
            }
        }
        else 
        {
            //copy image from buffer 
           // strncpy((char*)read_img_sector,(char*)buffer,IMG_BUFFER_SIZE);
            for(int i = 0; i<IMG_BUFFER_SIZE; i++ )
            {
                read_img_sector[i] = buffer[i];

            }
           ESP.flashEraseSector((image_address + idx)/SECTOR_SIZE);

            Serial.println("Writing image to nvs");

            ESP.flashWrite((image_address + idx), (uint32_t *)&read_img_sector, SECTOR_SIZE);

            Serial.print("Image saved to image sector: ");
            Serial.print(idx);
            Serial.println(" - First half");
            return true;
        } 
    }
    return false;
}

//added for testing without camera
void save_dummy_image_to_nvs(void)
{

    //erase three sectors of memory
    ESP.flashEraseSector((image_address_sector_1)/SECTOR_SIZE);
    ESP.flashEraseSector((image_address_sector_2)/SECTOR_SIZE);
    ESP.flashEraseSector((image_address_sector_3)/SECTOR_SIZE);

    for(int i = 0; i< IMG_BUFFER_SIZE; i++)
    {
        ESP.flashWrite(image_address_sector_1+(i*1), (uint32_t *)&dummy_image[i], 1);
        delay(1);
    }

    Serial.println("Image is saved in the memory");
}

void update_image_sector(uint32_t addr)
{

    ESP.flashEraseSector((addr)/SECTOR_SIZE);
    ESP.flashWrite(addr, (uint32_t *)&read_img_sector, SECTOR_SIZE);
}

uint8_t * read_image_from_nvs(void)
{
    static uint8_t image[IMG_BUFFER_SIZE] = {0};

    for(int idx = 0; idx < (3*SECTOR_SIZE); idx+=SECTOR_SIZE)
    {
        Serial.println("Read image from nvs");

        ESP.flashRead((image_address+idx), (uint32_t *)&read_img_sector, SECTOR_SIZE);
        
        if(read_img_sector[0] == 0xFF && read_img_sector[1] == 0xD8)
        {
           // strncpy((char*)image,(char*)read_img_sector,IMG_BUFFER_SIZE);
            for(int i = 0; i<IMG_BUFFER_SIZE; i++)
            {
                image[i] = read_img_sector[i];
            }
            memset(read_img_sector,0,SECTOR_SIZE/2);
            Serial.print("Image is retrived from image Sector:");
            Serial.println(idx+1);
            update_image_sector(image_address+idx);
            return image;
        }
        else
        {
            if(read_img_sector[0+(SECTOR_SIZE/2)] == 0xFF && read_img_sector[1+(SECTOR_SIZE/2)] == 0xD8)
            {
                //strncpy((char*)image,(char*)read_img_sector+(SECTOR_SIZE/2),IMG_BUFFER_SIZE);
                for(int i = 0; i<IMG_BUFFER_SIZE; i++)
                {
                    image[i+(SECTOR_SIZE/2)] = read_img_sector[i];
                }
                memset(read_img_sector+(SECTOR_SIZE/2),0,SECTOR_SIZE/2);
                Serial.print("Image is retrived from image Sector:");
                Serial.println(idx+1);
                update_image_sector(image_address+idx);
                return image;
            }
            else
            {
                Serial.print("No image found at image sector: ");
                Serial.println(idx);
                

            }
        }
        memset(read_img_sector,0,SECTOR_SIZE);
        
    }



 /*   
    for(int i = 0; i< IMG_BUFFER_SIZE; i++)
    {
        Serial.print(image[i],HEX);
        Serial.print(",");
        if(i%16 == 0 && i != 0)
        {
          Serial.println();
        }

    } */
    
    return NULL;
}

bool is_nvs_stored_config_updated(dev_config_t *dev_config)
{
    char data;
    dev_config_t dummy;
    bool flag;
    memset(&dummy,0xFF,sizeof(dev_config_t));
    if(read_configurations_from_nvs(dev_config))
    {
        if(dummy.config_updated_in_nvs == dev_config->config_updated_in_nvs)
        {
            Serial.println("Nothing is stored in memory");
            return false;
        }
        else
        {
            flag = dev_config->config_updated_in_nvs;
            //check for valid update flag from nvs
            if(flag == true || flag == false)
            {
                return flag;
            }
            else
                return false;
        }
    }
    else
    {
        Serial.println("NVS Read Error!!");
        return false;
    }

}

void write_updated_config_to_nvs(dev_config_t *dev_config,event_flags_t *process_event)
{
    if(process_event->update_structure_in_nvs)
    {
        Serial.println("Write updated config structure to nvs");
        dev_config->config_updated_in_nvs = true;
        write_configurations_to_nvs(dev_config);
        process_event->update_structure_in_nvs = false;
    }
}
void write_default_config_to_nvs(dev_config_t *dev_config)
{
    write_configurations_to_nvs(dev_config);
}
